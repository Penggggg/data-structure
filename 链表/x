# 应用场景

> 缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？

- 最近最少使用策略 LRU
- 最少使用策略 LFU
- 先进先出策略 FIFO

```
举例：

你买了很多本技术书，但有一天你发现，这些书太多了，太占书房空间了，你要做个大扫除，扔掉一些书籍。那这个时候，你会选择扔掉哪些书呢？
```

# 跟数组的对比

![image](https://static001.geekbang.org/resource/image/d5/cd/d5d5bee4be28326ba3c28373808a62cd.jpg)

![image](https://static001.geekbang.org/resource/image/4f/68/4f63e92598ec2551069a0eef69db7168.jpg)

- 数组

需要一块【连续】的内存空间来存储，当根据预定当大小（如100MB），去申请一块连续的内存。

在总内存足够，但没有连续的100MB时，也会申请失败。

- 链表

不需要【连续】的内存

通过【指针】将零散的内存联起来

- 对比

```
1、数组的特点是，大小固定，某些容器如ArrayList，在扩容时会出现耗时（需要把数据拷贝到新申请的空间上）或申请失败的问题
2、链表天然地支持动态扩容
3、链表中的每个结点都需要额外的空间去存储指针，所以内存消耗会翻倍
```

# 链表的特点

> 在链表中插入或者删除一个数据，我们并不需要为了保持内存的【连续性【而搬移结点，在链表中插入和删除一个数据是非常快速的。

链表的插入、删除操作，仅需要考虑相邻点的指针改变，时间复杂度为O( 1 )

![image](https://static001.geekbang.org/resource/image/45/17/452e943788bdeea462d364389bd08a17.jpg)

- 弊端

由于内存地址不连续，无法通过寻址公式就能直接计算出对应的内存地址

因此需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。

链表随机访问，需要 O(n) 的时间复杂度。

# 双向链表

> 这是实际的软件开发中，也更加常用的链表结构

![image](https://static001.geekbang.org/resource/image/cb/0b/cbc8ab20276e2f9312030c313a9ef70b.jpg)

双向链表需要pre、next来存储相邻节点的地址，会比单链表占用更多的内存空间。

- 找前驱节点

> 链表在删除、插入两种操作中，均需要找到前驱结点。

相比与单链表，双向链表可以在给定某结点的情况下，以O(1)的时间复杂度下，找到前驱结点。

因此，双向链表比单链表有很大的优势。

- 有序双向链表

> 对于一个有序链表，每次查询时，根据查找值与p结点值的大小关系，可决定是往前还是往后查找。

查找时间比单链表要快一半。

- 小总结

> 双向链表尽管比较费内存，但还是比单链表的应用更加广泛。

# 设计思想

- 用空间换时间

> 当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构。

# 算法-LRU

> 使用LRU，设计缓存大小固定情况下的缓存更新策略

```
1、越靠近链表尾部的结点是越早之前访问的。
2、插入缓存结点时，判断缓存结点是否已经存在在链表中，若存在，则把缓存结点放到链表头部
3-1、若缓存结点不存在，且内存没满时，放到链表头部
3-2、若缓存结点不存在，且内存满了，则删除链表尾部，并把缓存结点放到头部
```

# 算法-回文字符串

> 若字符串是通过单链表来存储，该如何来判断是一个回文串呢？

```
1、使用快慢两个指针找到链表中点（慢指针每次前进一步，快指针每次前进两步）
2、在慢指针前进的过程中，修改其 next 指针，使得链表前半部分反序
3、对比前后两段指针
```













































