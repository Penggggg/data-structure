# 简介

> 当需要实现“排队”模型的时候，应该考虑队列这个数据结构。其场景有：根据权重“排队”、平衡消费或生产、异步任务回流。

# 广泛的应用

```
1、循环队列：环状的队列，避免了普通队列的数据搬移。场景有：Node异步任务队列
2、阻塞队列1：队列为空，生产者才能将资源插入队列。场景有：消息队列
3、阻塞队列2：队列某资源出队后，达到某条件，下一个资源才能出队列。场景有：http队列阻塞
3、非阻塞队列：队列满了的时候，若再有需要入队，则直接拒绝、丢弃请求。场景有：时间敏感型系统
4、优先队列：大顶堆（自上而下，值为从大到小，的一颗二叉树）。场景有：统计前x个高频元素。
5、并发队列：加速生产或消费。
```

# 顺序队列

> 通过【数组】实现的队列系统

- 特点
  - 受【连续空间】限制，会涉及数据搬移
  - 通过head、tail双指针的优化下，可以免去特点1的缺点

![image](https://static001.geekbang.org/resource/image/de/0d/dea27f2c505dd8d0b6b86e262d03430d.jpg)

- 环形队列

> 循环队列会浪费一个数组的存储空间，因为队满情况下tail不会存储数据。环形的关键，是确定好队空和队满的判定条件。为空：head === tail。已满：(tail+1)%n=head

![image](https://static001.geekbang.org/resource/image/3d/ec/3d81a44f8c42b3ceee55605f9aeedcec.jpg)

# 链式队列

> 通过【链表】实现的队列系统

- 特点
  - 队列可以无限长
  - 但有可能导致过多的请求在排队，响应时间敏感型系统可能要选择非阻塞队列（直接拒绝）

```
入队：tail.next = new_node(队尾链接new_node); tail = new_node;（重新指向tail）
出队：head = head.next;
```

# 阻塞队列

> 生产 & 消费模型。

- 控制生产速度

当“生产者”的生产速度过快，队列容易满载，需要直到“消费者”消费了，“生产者”才会被唤醒继续“生产”。

- 控制消费速度

游乐园门票

# 并发队列

> 通过增加队列的生产工厂个数或消费者个数，形成其中一端可同时操作队头/尾的模型

![image](https://static001.geekbang.org/resource/image/9f/67/9f539cc0f1edc20e7fa6559193898067.jpg)

# 应用（线程池）

> 在资源受限这类场景，可以通过队列平衡消费者和生产者的关系。

设置一个合理的队列大小，也是非常有讲究的。

队列太大导致等待的请求太多

队列太小会导致无法充分利用系统资源、发挥最大性能

# 应用（优先队列）

> 优先队列，实质是根据数据的权重，在出队时优先选择权重高的数据出队

可以在入队排好序，或出队时排序。