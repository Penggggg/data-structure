# 简介

> 栈的例子：洗碗时候叠在一起的盘子。我们只能从顶部，一个个地取、放碟子。栈，是一种“操作受限”的线性表。

# 特点

> 当需要满足“叠盘子”特性的需求，可以考虑栈这个数据结构。甚至通过“双栈”，实现对比、先后顺序、优先级等功能。

- 时间复杂度

> 因为操作受限，只有栈顶的2种操作，因此时间复杂度都是 O(1)

- 空间复杂度

> 空间复杂度是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。

这n个空间是必须的，无法省掉。但在在入栈和出栈过程中，只需要一两个临时变量存储空间，空间复杂度是 O(1)。

# 单栈应用（函数调用栈）

> 操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的【临时变量】。

```
int main() { 
    int a = 1; 
    int ret = 0; 
    int res = 0; 
    ret = add(3, 5); 
    res = a + ret;
}
int add(int x, int y) { 
    int sum = 0; 
    sum = x + y; 
    return sum;
}
```

![image](https://static001.geekbang.org/resource/image/17/1c/17b6c6711e8d60b61d65fb0df5559a1c.jpg)

# 双栈应用（表达式求值）

> 【操作栈】增加“优先级”的对比，可以实现优先级高的操作服，在低优先级操作符入栈前，先进行计算。即：先“乘除”后“加减”

```
3 + 5 * 8 - 6
```

先从左向右遍历表达式

当遇到数字，我们就直接压入操作数栈

当遇到运算符，就与运算符栈的栈顶元素进行比较:

- 运算符比较
  - 比栈顶元素的优先级高，就将当前运算符压入栈
  - 优先级更低或者相同
    - 运算符栈，取一个运算符
    - 操作数栈，取 2 个操作数
    - 计算后，把结果压入操作数栈

![image](https://static001.geekbang.org/resource/image/bc/00/bc77c8d33375750f1700eb7778551600.jpg)

# 双栈应用（浏览器历史机制）

> 栈1用来装载“看过的页面”，其栈顶为“当前的页面”。【回退】则把栈顶页面压到栈2。【前进】则把栈2的栈顶压到栈1

![image](https://static001.geekbang.org/resource/image/4b/3d/4b579a76ea7ebfc5abae2ad6ae6a3c3d.jpg)

```
【回退】核心代码: 
stack2.unshift( stack1.shift( ))

【前进】核心代码：
stack1.unshift( stack2.shift( ))

特殊处理：
页面a突然要跳到未知页面X，此时应该清空stack2
```

# 单栈应用（有效括号）

```
输入: "()[]{}", 输出: true
输入: "{[]}"，输出: true
输入: "([)]"，输出: false
```

> 从左到右遍历，遇“左”则装到栈，遇“右”则判断栈顶是否匹配

```
【栈顶匹配】核心代码：

if ( 遇到“右” ) {
    isMatch( “右”, stack.shift( ))
}
```





















